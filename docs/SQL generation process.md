# SQL generation for data extracts

The SQL required for data extracts should be generated from templates rather than created freehand. This has two main advantages:

1. Fragments of SQL can be reused across multiple queries.
2. Clinical codes sets can be stored and version controlled separately to the SQL and injected when required.

This doc describes the process for the SQL generation.

## Clinical code sets

The GMCR receives data from EMIS, Vision and TPP practices. This means there is a combination of Read v2, CTV3, SNOMED and EMIS clinical codes. GraphNet attempt to link the codes (using the standard linking files from NHS Digital) so that in theory a single SNOMED code set could be used to match patients from any clinical system. However in practice this does not seem to match all codes. Therefore we ideally will have 4 code sets (Read v2, CTV3, SNOMED and EMIS) for each concept of interest. EMIS codes are most frequently found for medications, so it is likely for non-medication concepts we will only have 3 code sets (Read v2, CTV3 and SNOMED).

### Structure

The code sets live in this repository in the **_`TODO`_** directory. The file naming convention is as follows:

```
concept-separated-with-hyphens-[Readv2|CTV3|SNOMED|EMIS].txt
```

Examples would be:

- `hypertension-Readv2.txt`
- `aspirin-CTV3.txt`
- `atrial-fibrillation-CTV3.txt`
- `colonoscopy-SNOMED.txt`
- `beta-blockers-EMIS.txt`

If metadata on the codeset exists, such as that generated by tools such as [GetSet](https://getset.ga), that can be stored in the same directory with the following naming convention:

```
concept-[Readv2|CTV3|SNOMED|EMIS].metadata.txt
```

## Project structure

Each research proposal should have it's own directory under `.\projects`. The naming convention for the project directories is `XXX - Name` where `XXX` is the project's assigned number, and `Name` is the name of the PI. The project directory is structured as follows:

```js
projects
├─ 001 - Grant //
│  ├─ extraction-sql //
│  │  ├─ file1.sql //
│  │  ├─ file2.sql //
│  │  ├─ ... //
│  └─ template-sql
│     ├─ file1.template.sql //
│     ├─ file2.template.sql //
│     ├─ ... //
├─ 002 - Williams //
```

The `template-sql` directory contains the SQL templates for each project. An automated script takes the templates and outputs SQL files into the `extraction-sql` directory.

There should be one `template.sql` file for each data file required by the project. Examples for naming might be:

```
copd-cohort-demographics.template.sql
copd-cohort-records.template.sql
matched-cohort-demographics.template.sql
matched-cohort-records.template.sql
cohort-hospitalisations.template.sql
```

## SQL Templates

There should be one `template.sql` file per data file to be extracted. The SQL must end with a single `SELECT` statement, the output of which is the required data file. Interim temporary tables can be created within each SQL file.

SQL templates should include a header describing the data file that will be extracted. More precisely this will describe the columns. It is probably easiest to copy an existing one as an example, but the syntax is as follows:

```SQL
--┌─────────────────────────────────┐
--│ Descriptive name of the file    │
--└─────────────────────────────────┘

-- OUTPUT: Data with the following fields
-- 	•	Date (YYYY-MM-DD)
--	•	ConsultationType (face2face/remote/home visit/ooh/other)
-- 	•	CCG (Bolton/Salford/HMR/etc.)
```

Please note the following for the final `SELECT` statement:

1. Immediately prior to the final `SELECT` statment it is suggested to include a `PRINT` statement so that the data file will have column headers.
2. Data extraction is comma-separated by default, so if extracting data that may contain ","s, these can be removed prior to extraction using the `REPLACE` command.
3. `NULL` values tend not to work with stats packages so it's usually better to replace with an empty string, 'NA' or 0 depending on the situation. `ISNULL` can be used for this.

An example with all 3 is as follows:

```sql
PRINT 'PatientId,IndexDate,Code,Description';
SELECT
  PatientId,
  ISNULL(IndexDate,''), -- replacing null index dates with the empty string
  Code,
  ISNULL(REPLACE(Description,',',' '),'') -- replacing ","s with spaces and replacing NULL values
FROM ...
```

## Reusing SQL

Any SQL code that can be reused is placed under [./shared/Reusable queries for data extraction](../shared/Reusable%20queries%20for%20data%20extraction). Reusable code must have a header similar to the individual templates above. The syntax is below, but again, copying an existing query is likely the easiest option.

```sql
--┌─────────────────────────────┐
--│ Descriptive name of the sql │
--└─────────────────────────────┘

-- OBJECTIVE: The objective of this SQL. This is required. It can also
--            wrap onto more than one line like this.

-- ASSUMPTIONS:
--	-	This is an optional field
--	-	But where there are key assumptions that the analysts should know about
--    then they go here like this.
--	-	This means when the SQL is used in a data extract, we can provide the
--    analysts with a report showing the assumptions and limiations which they
--    can then optionally use in their work and final publication.

-- INPUT: Some templates only work if there already exists a temporary
--        table in the SQL session. E.g. a chunk of SQL that finds the
--        ethnicity information for a cohort of patients, might require
--        that there already exists a temporary table called #Patients
--        with an integer column called PatientId. The description of what
--        is required can go here. If no pre-requisites, please state that
--        explicitly.

-- OUTPUT: A description of the temporary tables that this query creates
-- #TableName (ColumnName1, ColumnName2, ColumnName3)
-- 	- ColumnName1 - description of this column
--	- ColumnName2 - state the type e.g. date, int, varchar etc..
--	- ColumnName3 - and anything else of interest
--
```

The syntax for then injecting these reusable chunks of SQL is as follows:

```sql
--> EXECUTE sql-file-to-execute.sql
```

The SQL file referenced should exist under [./shared/Reusable queries for data extraction](../shared/Reusable%20queries%20for%20data%20extraction).

## Referencing code sets

Any query that requires code sets should include the following in the template prior to using the code sets:

```sql
--> EXECUTE load-code-sets.sql
```

This populates two temporary tables as follows:

```
#CodeSets
Concept, FK_Coding_ID

#SnomedSets
Concept, FK_SNOMED_ID
```

Which can be used as follows:

```sql
SELECT * FROM [RLS].[vw_GP_Events]
WHERE (
  FK_Coding_ID IN (SELECT FK_Coding_ID FROM #CodeSets WHERE Concept = 'hypertension') OR
  FK_SNOMED_ID IN (SELECT FK_SNOMED_ID FROM #SnomedSets WHERE Concept = 'hypertension')
)
AND ...
```

## Process for generating SQL

The sql can be generated as follows:

-
