const { readFileSync, readdirSync, writeFileSync } = require('fs');
const { join } = require('path');

const LTC_DIRECTORY = join(__dirname, '..', 'shared', 'Long-term conditions');
const OUTPUT_DIR = join(__dirname, '..', 'shared', 'Reusable queries for data extraction');
const OUTPUT_FILE = join(OUTPUT_DIR, 'query-patient-ltcs.sql');
const OUTPUT_AT_INDEX_DATE_FILE = join(OUTPUT_DIR, 'query-patient-ltcs-at-index-date.sql');
const OUTPUT_CODE_SETS = join(OUTPUT_DIR, 'query-patient-ltcs-code-sets.sql');
const OUTPUT_AT_INDEX_DATE_FILE_2 = join(
  OUTPUT_DIR,
  'query-patient-ltcs-at-index-date-without-code-sets.sql'
);
const OUTPUT_GROUP_FILE = join(OUTPUT_DIR, 'query-patient-ltcs-group.sql');
let LTCGroups;
let LTCCodesetsArray;
let LTCConditions;

const createLtcSql = () => {
  // A list of the LTC groups
  getListOfLTCGroups();

  // Get the code sets
  getCodesets();

  const sql = createSQL();
  writeFileSync(OUTPUT_FILE, sql);

  const indexSql = createIndexDateSQL({ includeCodeSetCode: true });
  writeFileSync(OUTPUT_AT_INDEX_DATE_FILE, indexSql);

  const codeSets = ltcCodeSetBoilerPlate();
  writeFileSync(OUTPUT_CODE_SETS, codeSets);

  const index2Sql = createIndexDateSQL({ includeCodeSetCode: false });
  writeFileSync(OUTPUT_AT_INDEX_DATE_FILE_2, index2Sql);

  const groupSql = createGroupSQL();
  writeFileSync(OUTPUT_GROUP_FILE, groupSql);
};

// createLtcSql();

module.exports = { createLtcSql };

//
// FUNCTIONS
//

function getListOfLTCGroups() {
  validateLTCDirectory();
  LTCGroups = readdirSync(LTC_DIRECTORY, { withFileTypes: true }) // read all children of the LTC directory
    .filter((item) => item.isDirectory()) // ..then filter to just directories under LTC_DIRECTORY
    .map((dir) => dir.name.replace(/'/g, '')); // ..then return the directory name
}

function validateLTCDirectory() {
  if (
    readdirSync(LTC_DIRECTORY, { withFileTypes: true }).filter((item) => item.isFile()).length > 0
  ) {
    console.error(
      'ERROR>>> There are files in the LTC directory. I was only expecting to see directories.'
    );
  }
}

function getCodesets() {
  // Objects to store the code sets
  const codeSetObject = {};
  LTCCodesetsArray = [];

  LTCGroups.forEach((ltcGroup) => {
    codeSetObject[ltcGroup] = {};

    // Get all condition code lists for this group
    const CONDITION_DIRECTORY = join(LTC_DIRECTORY, ltcGroup);

    // A list of the condition code sets in this LTC group
    const conditionCodeSets = readdirSync(CONDITION_DIRECTORY, { withFileTypes: true })
      .filter((item) => item.isFile()) // find all files under LTC_DIRECTORY
      .map((file) => file.name) // return the file name
      .filter((filename) => filename.toLowerCase().match(/^.+\.(readv2|ctv3|snomed|emis).txt$/));

    // Add the code sets
    conditionCodeSets.forEach((conditionCodeSet) => {
      const [conditionLowerHyphens, dxOrRx, terminology] = conditionCodeSet.split('.');
      if (['medication', 'diagnosis'].indexOf(dxOrRx) < 0) {
        console.log(
          `The file ${conditionCodeSet} in ${CONDITION_DIRECTORY} does not match the following naming convention:`
        );
        console.log(
          'hyphenated-condition-name.[diagnosis|medication].[readv2|ctv3|snomed|emis].txt'
        );
        return;
      }
      const condition = conditionLowerHyphens
        .replace(/'/g, '')
        .split('-')
        .map((x) => `${x[0].toUpperCase()}${x.slice(1)}`)
        .join(' ');
      if (!codeSetObject[ltcGroup][conditionLowerHyphens]) {
        codeSetObject[ltcGroup][conditionLowerHyphens] = {};
      }
      if (!codeSetObject[ltcGroup][conditionLowerHyphens][terminology]) {
        codeSetObject[ltcGroup][conditionLowerHyphens][terminology] = {};
      }
      codeSetObject[ltcGroup][conditionLowerHyphens][terminology][dxOrRx] = loadCodeset(
        ltcGroup,
        conditionCodeSet,
        terminology
      );
      LTCCodesetsArray.push({
        ltcGroup,
        condition,
        terminology,
        dxOrRx,
        codes: codeSetObject[ltcGroup][conditionLowerHyphens][terminology],
      });
    });
  });

  LTCConditions = makeArrayUnique(LTCCodesetsArray.map((x) => x.condition));
}

function createGroupSQL() {
  const sql = `--
--┌────────────────────────────────────────┐
--│ Long-term condition groups per patient │
--└────────────────────────────────────────┘

-- OBJECTIVE: To provide the long-term condition group or groups for each patient. Examples
--            of long term condition groups would be: Cardiovascular, Endocrine, Respiratory

-- INPUT: Assumes there exists a temp table as follows:
-- #PatientsWithLTCs (FK_Patient_Link_ID, LTC)
-- Therefore this is run after query-patient-ltcs.sql

-- OUTPUT: A temp table with a row for each patient and ltc group combo
-- #LTCGroups (FK_Patient_Link_ID, LTCGroup)

--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--!!! DO NOT EDIT THIS FILE MANUALLY - see "node create-ltc-sql.js" !!!
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

-- Calculate the LTC groups for each patient
IF OBJECT_ID('tempdb..#LTCGroups') IS NOT NULL DROP TABLE #LTCGroups;
SELECT 
  DISTINCT FK_Patient_Link_ID, 
  CASE
    ${LTCGroups.map(
      (group) => `WHEN LTC IN ('${getConditionsFromGroup(group).join("','")}') THEN '${group}'`
    ).join('\n\t\t')}
  END AS LTCGroup INTO #LTCGroups
FROM #PatientsWithLTCs;
`;
  return sql;
}

function getConditionsFromGroup(group) {
  return makeArrayUnique(
    LTCCodesetsArray.filter((x) => x.ltcGroup === group).map((x) => x.condition)
  );
}

function ltcCodeSetBoilerPlate() {
  return `--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
--!!! DO NOT EDIT THIS FILE MANUALLY - see "node create-ltc-sql.js" !!!
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

${
  hasTerminology('emis')
    ? `IF OBJECT_ID('tempdb..#ltccodesemis') IS NOT NULL DROP TABLE #ltccodesemis;
CREATE TABLE #ltccodesemis (
  [condition] [varchar](255) NOT NULL,
  [group] [varchar](255) NOT NULL,
  [diagnosisOrMedication] [varchar](255) NOT NULL,
  [code] [varchar](20) COLLATE Latin1_General_CS_AS NOT NULL,
  [description] [varchar](255) NULL
)ON [PRIMARY];

${getInsertStatementForTerminology('emis')};`
    : ''
}

${
  hasTerminology('readv2')
    ? `IF OBJECT_ID('tempdb..#ltccodesreadv2') IS NOT NULL DROP TABLE #ltccodesreadv2;
CREATE TABLE #ltccodesreadv2 (
  [condition] [varchar](255) NOT NULL,
  [group] [varchar](255) NOT NULL,
  [diagnosisOrMedication] [varchar](255) NOT NULL,
  [code] [varchar](20) COLLATE Latin1_General_CS_AS NOT NULL,
  [description] [varchar](255) NULL
) ON [PRIMARY];

${getInsertStatementForTerminology('readv2')};`
    : ''
}

${
  hasTerminology('ctv3')
    ? `IF OBJECT_ID('tempdb..#ltccodesctv3') IS NOT NULL DROP TABLE #ltccodesctv3;
CREATE TABLE #ltccodesctv3 (
  [condition] [varchar](255) NOT NULL,
  [group] [varchar](255) NOT NULL,
  [diagnosisOrMedication] [varchar](255) NOT NULL,
  [code] [varchar](20) COLLATE Latin1_General_CS_AS NOT NULL,
  [description] [varchar](255) NULL
) ON [PRIMARY];

${getInsertStatementForTerminology('ctv3')};`
    : ''
}

${
  hasTerminology('snomed')
    ? `IF OBJECT_ID('tempdb..#ltccodessnomed') IS NOT NULL DROP TABLE #ltccodessnomed;
CREATE TABLE #ltccodessnomed (
  [condition] [varchar](255) NOT NULL,
  [group] [varchar](255) NOT NULL,
  [diagnosisOrMedication] [varchar](255) NOT NULL,
  [code] [varchar](20) COLLATE Latin1_General_CS_AS NOT NULL,
  [description] [varchar](255) NULL
) ON [PRIMARY];

${getInsertStatementForTerminology('snomed')};`
    : ''
}

IF OBJECT_ID('tempdb..#LtcTempRefCodes') IS NOT NULL DROP TABLE #LtcTempRefCodes;
CREATE TABLE #LtcTempRefCodes (FK_Reference_Coding_ID BIGINT NOT NULL, condition VARCHAR(255) NOT NULL, [group] VARCHAR(255) NOT NULL);

${
  hasTerminology('emis')
    ? `-- EMIS codes with a FK Reference Coding ID
INSERT INTO #LtcTempRefCodes
SELECT FK_Reference_Coding_ID, dce.condition, dce.[group]
FROM [SharedCare].[Reference_Local_Code] rlc
INNER JOIN #ltccodesemis dce on dce.code = rlc.LocalCode
WHERE FK_Reference_Coding_ID != -1;`
    : ''
}

${
  hasTerminology('readv2')
    ? `-- Read v2 codes
INSERT INTO #LtcTempRefCodes
SELECT PK_Reference_Coding_ID, dcr.condition, dcr.[group]
FROM [SharedCare].[Reference_Coding] rc
INNER JOIN #ltccodesreadv2 dcr on dcr.code = rc.MainCode
WHERE CodingType='ReadCodeV2'
and PK_Reference_Coding_ID != -1;`
    : ''
}

${
  hasTerminology('ctv3')
    ? `-- CTV3 codes
INSERT INTO #LtcTempRefCodes
SELECT PK_Reference_Coding_ID, dcc.condition, dcc.[group]
FROM [SharedCare].[Reference_Coding] rc
INNER JOIN #ltccodesctv3 dcc on dcc.code = rc.MainCode
WHERE CodingType='CTV3'
and PK_Reference_Coding_ID != -1;`
    : ''
}

IF OBJECT_ID('tempdb..#LtcTempSNOMEDRefCodes') IS NOT NULL DROP TABLE #LtcTempSNOMEDRefCodes;
CREATE TABLE #LtcTempSNOMEDRefCodes (FK_Reference_SnomedCT_ID BIGINT NOT NULL, condition VARCHAR(255) NOT NULL, [group] VARCHAR(255) NOT NULL);

${
  hasTerminology('emis')
    ? `-- EMIS codes with a FK SNOMED ID but without a FK Reference Coding ID
INSERT INTO #LtcTempSNOMEDRefCodes
SELECT FK_Reference_SnomedCT_ID, dce.condition, dce.[group]
FROM [SharedCare].[Reference_Local_Code] rlc
INNER JOIN #ltccodesemis dce on dce.code = rlc.LocalCode
WHERE FK_Reference_Coding_ID = -1
AND FK_Reference_SnomedCT_ID != -1;`
    : ''
}

${
  hasTerminology('snomed')
    ? `-- SNOMED codes
INSERT INTO #LtcTempSNOMEDRefCodes
SELECT PK_Reference_SnomedCT_ID, dcs.condition, dcs.[group]
FROM SharedCare.Reference_SnomedCT rs
INNER JOIN #ltccodessnomed dcs on dcs.code = rs.ConceptID;`
    : ''
}

-- De-duped tables
IF OBJECT_ID('tempdb..#RefCodes') IS NOT NULL DROP TABLE #RefCodes;
IF OBJECT_ID('tempdb..#SNOMEDRefCodes') IS NOT NULL DROP TABLE #SNOMEDRefCodes;
CREATE TABLE #RefCodes (FK_Reference_Coding_ID BIGINT NOT NULL, condition VARCHAR(255) NOT NULL, [group] VARCHAR(255) NOT NULL);
CREATE TABLE #SNOMEDRefCodes (FK_Reference_SnomedCT_ID BIGINT NOT NULL, condition VARCHAR(255) NOT NULL, [group] VARCHAR(255) NOT NULL);

INSERT INTO #RefCodes
SELECT DISTINCT * FROM #LtcTempRefCodes;

INSERT INTO #SNOMEDRefCodes
SELECT DISTINCT * FROM #LtcTempSNOMEDRefCodes;`;
}

function createIndexDateSQL({ includeCodeSetCode }) {
  const conditions = {
    AtrialFibrillation: { type: 'dx', queryString: 'Atrial Fibrillation' },
    CoronaryHeartDisease: { type: 'dx', queryString: 'Coronary Heart Disease' },
    HeartFailure: { type: 'dx', queryString: 'Heart Failure' },
    Hypertension: { type: 'dx', queryString: 'Hypertension' },
    PeripheralVascularDisease: { type: 'dx', queryString: 'Peripheral Vascular Disease' },
    StrokeAndTia: { type: 'dx', queryString: 'Stroke And Tia' },
    Diabetes: { type: 'dx', queryString: 'Diabetes' },
    ThyroidDisorders: { type: 'dx', queryString: 'Thyroid Disorders' },
    ChronicLiverDisease: { type: 'dx', queryString: 'Chronic Liver Disease' },
    DiverticularDiseaseOfIntestine: {
      type: 'dx',
      queryString: 'Diverticular Disease Of Intestine',
    },
    InflammatoryBowelDisease: { type: 'dx', queryString: 'Inflammatory Bowel Disease' },
    PepticUlcerDisease: { type: 'dx', queryString: 'Peptic Ulcer Disease' },
    RheumatoidArthritisAndOtherInflammatoryPolyarthropathies: {
      type: 'dx',
      queryString: 'Rheumatoid Arthritis And Other Inflammatory Polyarthropathies',
    },
    MultipleSclerosis: { type: 'dx', queryString: 'Multiple Sclerosis' },
    ParkinsonsDisease: { type: 'dx', queryString: 'Parkinsons Disease' },
    AnorexiaOrBulimia: { type: 'dx', queryString: 'Anorexia Or Bulimia' },
    AnxietyAndOtherSomatoformDisorders: {
      type: 'dx',
      queryString: 'Anxiety And Other Somatoform Disorders',
    },
    Dementia: { type: 'dx', queryString: 'Dementia' },
    Depression: { type: 'dx', queryString: 'Depression' },
    SchizophreniaOrBipolar: { type: 'dx', queryString: 'Schizophrenia Or Bipolar' },
    ChronicKidneyDisease: { type: 'dx', queryString: 'Chronic Kidney Disease' },
    ProstateDisorders: { type: 'dx', queryString: 'Prostate Disorders' },
    Asthma: { type: 'dx', queryString: 'Asthma' },
    Bronchiectasis: { type: 'dx', queryString: 'Bronchiectasis' },
    ChronicSinusitis: { type: 'dx', queryString: 'Chronic Sinusitis' },
    COPD: { type: 'dx', queryString: 'COPD' },
    BlindnessAndLowVision: { type: 'dx', queryString: 'Blindness And Low Vision' },
    Glaucoma: { type: 'dx', queryString: 'Glaucoma' },
    HearingLoss: { type: 'dx', queryString: 'Hearing Loss' },
    LearningDisability: { type: 'dx', queryString: 'Learning Disability' },
    AlcoholProblems: { type: 'dx', queryString: 'Alcohol Problems' },
    PsychoactiveSubstanceAbuse: { type: 'dx', queryString: 'Psychoactive Substance Abuse' },
    Cancer: { type: 'dx', queryString: 'Cancer', number: 1, timespanYears: 5 },
    PainfulCondition: { type: 'rx', queryString: 'Painful Condition', number: 4, timespanYears: 1 },
    Migraine: { type: 'rx', queryString: 'Migraine', number: 4, timespanYears: 1 },
    Constipation: { type: 'rx', queryString: 'Constipation', number: 4, timespanYears: 1 },
    Epilepsy: { type: 'both', queryString: 'Epilepsy', number: 1, timespanYears: 1 },
    PsoriasisOrEczema: {
      type: 'both',
      queryString: 'Psoriasis Or Eczema',
      number: 4,
      timespanYears: 1,
    },
    IrritableBowelSyndrome: {
      type: 'both',
      queryString: 'Irritable Bowel Syndrome',
      number: 4,
      timespanYears: 1,
    },
    Dyspepsia: { type: 'rx', queryString: 'Dyspepsia', number: 4, timespanYears: 1 },
  };

  return `
--┌─────────────────────────────────────────────────────────┐
--│ Long-term condition groups per patient at an index date │
--└─────────────────────────────────────────────────────────┘

-- OBJECTIVE: To provide the long-term condition group or groups for each patient. Examples
--            of long term condition groups would be: Cardiovascular, Endocrine, Respiratory
--            Provides Y/N flag for each condition at some index date unique to each person.

-- INPUT: Takes two parameters
--	- gp-events-table: string - (table name) the name of the table containing the GP events. Usually is "SharedCare.GP_Events" but can be anything with the columns: FK_Patient_Link_ID, EventDate, FK_Reference_Coding_ID and FK_Reference_SnomedCT_ID
--	- gp-medications-table: string - (table name) the name of the table containing the GP medications. Usually is "SharedCare.GP_Medications" but can be anything with the columns: FK_Patient_Link_ID, EventDate, FK_Reference_Coding_ID and FK_Reference_SnomedCT_ID
--  Assumes there exists a temp table as follows:
--    #PatientsWithIndexDates  (FK_Patient_Link_ID, IndexDate)

-- OUTPUT: A temp table with a row for each patient and 40 Y/N columns
-- #LTCOnIndexDate (PatientId, HasCOPD, HasAsthma, Has...)

${includeCodeSetCode ? ltcCodeSetBoilerPlate() : ''}

-- Now for each condition make a separate table with the patient id and date
${Object.entries(conditions)
  .filter(([, { type }]) => type !== 'rx')
  .map(
    ([condition, { queryString }]) =>
      `IF OBJECT_ID('tempdb..#${condition}DxTable') IS NOT NULL DROP TABLE #${condition}DxTable;
SELECT FK_Patient_Link_ID, EventDate INTO #${condition}DxTable FROM {param:gp-events-table} WHERE FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = '${queryString}');`
  )
  .join('\n')}

-- Now for each condition add in the codes from the reference coding id rather than the snomed one (will
-- lead to duplicates but that doesn't matter)
${Object.entries(conditions)
  .filter(([, { type }]) => type !== 'rx')
  .map(
    ([condition, { queryString }]) =>
      `INSERT INTO #${condition}DxTable
SELECT FK_Patient_Link_ID, EventDate FROM {param:gp-events-table} WHERE FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = '${queryString}');`
  )
  .join('\n')}

-- For medication codes we do a similar thing, but deduplicate as there is a high
-- degree of overlap, and also we don't want to count a drug twice in one day as
-- more than one drug.
${Object.entries(conditions)
  .filter(([, { type }]) => type !== 'dx')
  .map(
    ([condition, { queryString }]) =>
      `IF OBJECT_ID('tempdb..#${condition}RxTableA') IS NOT NULL DROP TABLE #${condition}RxTableA;
SELECT FK_Patient_Link_ID, MedicationDate INTO #${condition}RxTableA FROM {param:gp-medications-table} 
WHERE FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = '${queryString}');
INSERT INTO #${condition}RxTableA
SELECT FK_Patient_Link_ID, MedicationDate FROM {param:gp-medications-table} 
WHERE FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = '${queryString}');
IF OBJECT_ID('tempdb..#${condition}RxTable') IS NOT NULL DROP TABLE #${condition}RxTable;
SELECT DISTINCT * INTO #${condition}RxTable FROM #${condition}RxTableA;`
  )
  .join('\n')}

  ${Object.entries(conditions)
    .filter(([, { type }]) => type === 'rx')
    .map(
      ([
        condition,
        { number, timespanYears, queryString },
      ]) => `-- ${queryString} >= ${number} Rx in last ${timespanYears} year
IF OBJECT_ID('tempdb..#${condition}Table') IS NOT NULL DROP TABLE #${condition}Table;
SELECT patients.FK_Patient_Link_ID, patients.IndexDate AS EventDate
INTO #${condition}Table
FROM #PatientsWithIndexDates patients
LEFT OUTER JOIN #${condition}RxTable medSubTable
  ON medSubTable.FK_Patient_Link_ID = patients.FK_Patient_Link_ID
  AND patients.IndexDate >= medSubTable.MedicationDate
  AND patients.IndexDate < DATEADD(year, ${timespanYears}, medSubTable.MedicationDate)
GROUP BY patients.FK_Patient_Link_ID, patients.IndexDate
HAVING COUNT(medSubTable.MedicationDate) >=${number};`
    )
    .join('\n\n')}

-- For most conditions we just need to know if they ever had the condition
${Object.entries(conditions)
  .filter(([, { type, timespanYears }]) => type === 'dx' && !timespanYears)
  .map(
    ([condition]) =>
      `IF OBJECT_ID('tempdb..#${condition}Table') IS NOT NULL DROP TABLE #${condition}Table;
SELECT FK_Patient_Link_ID, MIN(EventDate) AS EventDate INTO #${condition}Table FROM #${condition}DxTable GROUP BY FK_Patient_Link_ID;`
  )
  .join('\n')}


-- Cancer only if first diagnosis in last 5 years
IF OBJECT_ID('tempdb..#CancerTable') IS NOT NULL DROP TABLE #CancerTable;
SELECT patients.FK_Patient_Link_ID, patients.IndexDate AS EventDate
INTO #CancerTable
FROM #PatientsWithIndexDates patients
LEFT OUTER JOIN #CancerDxTable dxSubTable
	ON dxSubTable.FK_Patient_Link_ID = patients.FK_Patient_Link_ID
	AND patients.IndexDate >= dxSubTable.EventDate
GROUP BY patients.FK_Patient_Link_ID, patients.IndexDate
HAVING COUNT(dxSubTable.EventDate) >=1 AND MIN(dxSubTable.EventDate) > DATEADD(year, -5, patients.IndexDate);

${Object.entries(conditions)
  .filter(([, { type }]) => type === 'both')
  .map(
    ([condition, { number, timespanYears, queryString }]) => `-- ${queryString} read code ever
IF OBJECT_ID('tempdb..#${condition}Table') IS NOT NULL DROP TABLE #${condition}Table;
SELECT patients.FK_Patient_Link_ID, patients.IndexDate AS EventDate
INTO #${condition}Table
FROM #PatientsWithIndexDates patients
LEFT OUTER JOIN #${condition}DxTable dxSubTable
  ON dxSubTable.FK_Patient_Link_ID = patients.FK_Patient_Link_ID
  AND patients.IndexDate >= dxSubTable.EventDate
GROUP BY patients.FK_Patient_Link_ID, patients.IndexDate
HAVING COUNT(dxSubTable.EventDate) >=1
--  AND ${queryString} Rx in last year
INTERSECT
SELECT patients.FK_Patient_Link_ID, patients.IndexDate FROM #PatientsWithIndexDates patients
LEFT OUTER JOIN #${condition}RxTable rxSubTable
  ON rxSubTable.FK_Patient_Link_ID = patients.FK_Patient_Link_ID
  AND patients.IndexDate >= rxSubTable.MedicationDate
  AND patients.IndexDate < DATEADD(year, ${timespanYears}, rxSubTable.MedicationDate)
GROUP BY patients.FK_Patient_Link_ID, patients.IndexDate
HAVING COUNT(rxSubTable.MedicationDate) >=${number}
ORDER BY patients.FK_Patient_Link_ID;`
  )
  .join('\n\n')}

IF OBJECT_ID('tempdb..#LTCOnIndexDate') IS NOT NULL DROP TABLE #LTCOnIndexDate;
SELECT 
  patients.FK_Patient_Link_ID AS PatientId,
${Object.entries(conditions)
  .map(
    ([condition]) =>
      `  CASE WHEN SUM(CASE WHEN ${condition.toLowerCase()}.EventDate IS NULL THEN 0 ELSE 1 END) > 0 THEN 'Y' ELSE 'N' END AS Has${condition}`
  )
  .join(',\n')}
INTO #LTCOnIndexDate
FROM #PatientsWithIndexDates patients
${Object.entries(conditions)
  .map(
    ([condition]) =>
      `LEFT OUTER JOIN #${condition}Table ${condition.toLowerCase()} ON ${condition.toLowerCase()}.FK_Patient_Link_ID = patients.FK_Patient_Link_ID AND ${condition.toLowerCase()}.EventDate <= patients.IndexDate`
  )
  .join('\n')}
GROUP BY patients.FK_Patient_Link_ID
`;
}

function createSQL() {
  const specialConditions = [
    'Cancer',
    'Irritable Bowel Syndrome',
    'Constipation',
    'Dyspepsia',
    'Painful Condition',
    'Epilepsy',
    'Migraine',
    'Psoriasis Or Eczema',
  ];
  const sql = `--
--┌──────────────────────┐
--│ Long-term conditions │
--└──────────────────────┘

-- OBJECTIVE: To get every long-term condition for each patient.

-- INPUT: Assumes there exists a temp table as follows:
-- #Patients (FK_Patient_Link_ID)
-- A distinct list of FK_Patient_Link_IDs for each patient in the cohort

-- OUTPUT: A temp table with a row for each patient and ltc combo
-- #PatientsWithLTCs (FK_Patient_Link_ID, LTC)

-- Get the LTCs that each patient had prior to @StartDate

${ltcCodeSetBoilerPlate()}

IF OBJECT_ID('tempdb..#LTCTemp') IS NOT NULL DROP TABLE #LTCTemp;
SELECT DISTINCT FK_Patient_Link_ID, EventDate, FK_Reference_SnomedCT_ID, FK_Reference_Coding_ID INTO #LTCTemp 
FROM RLS.vw_GP_Events e
WHERE (
	FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition NOT IN ('${specialConditions.join(
    "','"
  )}')) OR
  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition NOT IN ('${specialConditions.join(
    "','"
  )}'))
)
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
AND EventDate < @StartDate;

IF OBJECT_ID('tempdb..#LTCCancerTemp') IS NOT NULL DROP TABLE #LTCCancerTemp;
SELECT FK_Patient_Link_ID, EventDate INTO #LTCCancerTemp 
FROM RLS.vw_GP_Events e
WHERE (
	FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Cancer') OR
  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Cancer')
)
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
AND EventDate < @StartDate;

IF OBJECT_ID('tempdb..#LTCTempMedsLastYear') IS NOT NULL DROP TABLE #LTCTempMedsLastYear;
SELECT DISTINCT FK_Patient_Link_ID, CAST(MedicationDate AS DATE) AS MedicationDate, 
	CASE 
		WHEN (
		  FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Painful Condition') OR
		  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Painful Condition')
		) THEN 'Painful Condition'
		WHEN (
		  FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Migraine') OR
		  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Migraine')
		) THEN 'Migraine'
		WHEN (
		  FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Irritable Bowel Syndrome') OR
		  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Irritable Bowel Syndrome')
		) THEN 'Irritable Bowel Syndrome'
		WHEN (
		  FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Constipation') OR
		  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Constipation')
		) THEN 'Constipation'
		WHEN (
		  FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Epilepsy') OR
		  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Epilepsy')
		) THEN 'Epilepsy'
		WHEN (
		  FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Psoriasis Or Eczema') OR
		  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Psoriasis Or Eczema')
		) THEN 'Psoriasis Or Eczema'
		WHEN (
		  FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Dyspepsia') OR
		  FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Dyspepsia')
		) THEN 'Dyspepsia'
	END AS Condition 
INTO #LTCTempMedsLastYear 
FROM RLS.vw_GP_Medications
WHERE (
	FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition in ('Irritable Bowel Syndrome','Constipation','Dyspepsia','Painful Condition','Epilepsy','Psoriasis Or Eczema','Migraine')) OR
	FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition in ('Irritable Bowel Syndrome','Constipation','Dyspepsia','Painful Condition','Epilepsy','Psoriasis Or Eczema','Migraine'))
)
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
AND MedicationDate < @StartDate
AND MedicationDate >= DATEADD(year, -1, @StartDate);

IF OBJECT_ID('tempdb..#PatientsWithLTCs') IS NOT NULL DROP TABLE #PatientsWithLTCs;
CREATE TABLE #PatientsWithLTCs (FK_Patient_Link_ID BIGINT, LTC VARCHAR(100));

-- Painful condition >= 4 Rx in last year
INSERT INTO #PatientsWithLTCs
SELECT FK_Patient_Link_ID, Condition FROM #LTCTempMedsLastYear
WHERE Condition = 'Painful Condition'
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID, Condition
HAVING COUNT(*) >= 4;

-- Migraine >= 4 Rx in last year
INSERT INTO #PatientsWithLTCs
SELECT FK_Patient_Link_ID, Condition FROM #LTCTempMedsLastYear
WHERE Condition = 'Migraine'
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID, Condition
HAVING COUNT(*) >= 4;

-- Dyspepsia >= 4 Rx in last year
INSERT INTO #PatientsWithLTCs
SELECT FK_Patient_Link_ID, Condition FROM #LTCTempMedsLastYear
WHERE Condition = 'Dyspepsia'
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID, Condition
HAVING COUNT(*) >= 4;

-- Constipation >= 4 Rx in last year
INSERT INTO #PatientsWithLTCs
SELECT FK_Patient_Link_ID, Condition FROM #LTCTempMedsLastYear
WHERE Condition = 'Constipation'
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID, Condition
HAVING COUNT(*) >= 4;

-- Cancer only if first diagnosis in last 5 years
INSERT INTO #PatientsWithLTCs
SELECT FK_Patient_Link_ID, 'Cancer' FROM #LTCCancerTemp
WHERE FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID
HAVING MIN(EventDate) >= DATEADD(YEAR, -5, @StartDate);

-- Epilepsy read code ever AND Rx in last year
INSERT INTO #PatientsWithLTCs
SELECT DISTINCT FK_Patient_Link_ID, 'Epilepsy'
FROM RLS.vw_GP_Events e
WHERE (
	FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Epilepsy') OR
	FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Epilepsy')
)
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
AND EventDate < @StartDate
INTERSECT
SELECT FK_Patient_Link_ID, 'Epilepsy' FROM #LTCTempMedsLastYear
WHERE Condition = 'Epilepsy'
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID, Condition;

-- Psoriasis Or Eczema read code ever AND >= 4 Rx in last year
INSERT INTO #PatientsWithLTCs
SELECT DISTINCT FK_Patient_Link_ID, 'Psoriasis Or Eczema'
FROM RLS.vw_GP_Events e
WHERE (
	FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Psoriasis Or Eczema') OR
	FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Psoriasis Or Eczema')
)
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
AND EventDate < @StartDate
INTERSECT
SELECT FK_Patient_Link_ID, 'Psoriasis Or Eczema' FROM #LTCTempMedsLastYear
WHERE Condition = 'Psoriasis Or Eczema'
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID, Condition
HAVING COUNT(*) >= 4;

-- IBS read code ever OR >= 4 Rx in last year
-- Irritable Bowel Syndrome >= 4 Rx in last year
INSERT INTO #PatientsWithLTCs
SELECT FK_Patient_Link_ID, Condition FROM #LTCTempMedsLastYear
WHERE Condition = 'Irritable Bowel Syndrome'
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
GROUP BY FK_Patient_Link_ID, Condition
HAVING COUNT(*) >= 4;

-- IBS read code ever
INSERT INTO #PatientsWithLTCs
SELECT DISTINCT FK_Patient_Link_ID, 'Irritable Bowel Syndrome'
FROM RLS.vw_GP_Events e
WHERE (
	FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = 'Irritable Bowel Syndrome') OR
	FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = 'Irritable Bowel Syndrome')
)
AND FK_Patient_Link_ID IN (SELECT FK_Patient_Link_ID FROM #Patients)
AND EventDate < @StartDate;

-- All others just need read code ever
INSERT INTO #PatientsWithLTCs
SELECT DISTINCT 
  FK_Patient_Link_ID, 
  CASE
  ${LTCConditions.filter((condition) => specialConditions.indexOf(condition) < 0)
    .map(
      (condition) => `  WHEN (
      FK_Reference_SnomedCT_ID IN (SELECT FK_Reference_SnomedCT_ID FROM #SNOMEDRefCodes WHERE condition = '${condition}') OR
      FK_Reference_Coding_ID IN (SELECT FK_Reference_Coding_ID FROM #RefCodes WHERE condition = '${condition}')
    ) THEN '${condition}'`
    )
    .join('\n\t')}
  END AS LTC
FROM #LTCTemp;
`;
  return sql;
}

function hasTerminology(terminology) {
  return LTCCodesetsArray.filter((item) => item.terminology === terminology).length > 0;
}

function getInsertStatementForTerminology(terminology) {
  return LTCCodesetsArray.filter((item) => item.terminology === terminology)
    .map((item) => {
      let rtn = item.codes.diagnosis
        ? item.codes.diagnosis.map(
            (code) => `('${item.condition}','${item.ltcGroup}','${item.dxOrRx}','${code}','')`
          )
        : [];

      if (item.codes.medication) {
        rtn = rtn.concat(
          item.codes.medication.map(
            (code) => `('${item.condition}','${item.ltcGroup}','${item.dxOrRx}','${code}','')`
          )
        );
      }
      return rtn;
    })
    .flat()
    .filter((row) => row.length > 2)
    .reduce(
      (soFar, nextValue) => {
        if (soFar.itemCount === 999) {
          // SQL only allows 1000 items to be inserted after each INSERT INTO statememt
          // so need to start again
          soFar.sql = `${soFar.sql.slice(0, -1)};\nINSERT INTO #ltccodes${terminology}\nVALUES `;
          soFar.lineLength = 7;
          soFar.itemCount = 0;
        }
        if (soFar.lineLength > 9900) {
          // the sql management studio doesn't style lines much longer than this
          soFar.sql += `\n${nextValue},`;
          soFar.lineLength = nextValue.length + 1;
        } else {
          soFar.sql += `${nextValue},`;
          soFar.lineLength += nextValue.length + 1;
        }
        soFar.itemCount += 1;
        return soFar;
      },
      { sql: `INSERT INTO #ltccodes${terminology}\nVALUES `, itemCount: 0, lineLength: 7 }
    )
    .sql.slice(0, -1);
}

function loadCodeset(ltcGroup, conditionCodeSet, terminology) {
  if (terminology === 'readv2') return loadCodesetReadv2(ltcGroup, conditionCodeSet);
  if (terminology === 'ctv3') return loadCodesetCTV3(ltcGroup, conditionCodeSet);
  if (terminology === 'snomed') return loadCodesetSnomed(ltcGroup, conditionCodeSet);
  if (terminology === 'emis') return loadCodesetEmis(ltcGroup, conditionCodeSet);
}

function loadCodesetReadv2(ltcGroup, conditionCodeSet) {
  const filepath = join(LTC_DIRECTORY, ltcGroup, conditionCodeSet);
  const [fileHeader, ...fileBody] = readFileSync(filepath, 'utf8')
    .split('\n')
    .map((row) => row.split('\t'))
    .filter((items) => items.length > 1);
  if (!fileHeader) {
    console.log(`The file ${conditionCodeSet} in ${ltcGroup} does not have a header row.`);
    return [];
  }
  const readcodeIndex = fileHeader.map((x) => x.toLowerCase()).indexOf('readcode');

  if (readcodeIndex < 0) {
    console.log(
      `The file ${conditionCodeSet} in ${ltcGroup} does not have a column with the header 'readcode'.`
    );
    return [];
  }

  const codingSystemIndex = fileHeader.indexOf('CodingSystem');
  const codingSystemFilter =
    codingSystemIndex > -1
      ? (items) => items[codingSystemIndex].toLowerCase() === 'readcode'
      : () => true;
  const readcodes = fileBody.filter(codingSystemFilter).map((items) => items[readcodeIndex]);

  if (readcodes.length === 0) {
    console.log(`The file ${conditionCodeSet} in ${ltcGroup} does not have any read codes.`);
    return [];
  }

  // Add 5 byte codes if we have any 7 character ones
  // e.g. if the code is "G30..00" then we would also
  // add the code "G30.."
  const readcodeSet = {};
  readcodes.forEach((readcode) => {
    if (!readcode) {
      console.log(filepath);
      console.log(fileHeader);
      console.log(readcodes);
    }
    readcodeSet[readcode] = true;
    if (readcode.length === 7) {
      readcodeSet[readcode.substr(0, 5)] = true;
    }
  });
  return Object.keys(readcodeSet);
}

function loadCodesetCTV3(ltcGroup, conditionCodeSet) {
  const filepath = join(LTC_DIRECTORY, ltcGroup, conditionCodeSet);
  const [fileHeader, ...fileBody] = readFileSync(filepath, 'utf8')
    .split('\n')
    .map((row) => row.split('\t'))
    .filter((items) => items.length > 1);
  let ctv3Index = fileHeader.map((x) => x.toLowerCase()).indexOf('ctv3code');
  if (ctv3Index < 0) ctv3Index = fileHeader.map((x) => x.toLowerCase()).indexOf('ctv3id');
  if (ctv3Index < 0) {
    console.log(
      `The file ${conditionCodeSet} in ${ltcGroup} does not have a column with the header 'ctv3code' or 'ctv3id'.`
    );
    return [];
  }
  const ctv3Codes = fileBody.map((items) => items[ctv3Index]);

  if (ctv3Codes.length === 0) {
    console.log(`The file ${conditionCodeSet} in ${ltcGroup} does not have any ctv3 codes.`);
    return [];
  }

  return ctv3Codes;
}

function loadCodesetEmis(ltcGroup, conditionCodeSet) {
  const filepath = join(LTC_DIRECTORY, ltcGroup, conditionCodeSet);
  const [fileHeader, ...fileBody] = readFileSync(filepath, 'utf8')
    .split('\n')
    .map((row) => row.split('\t'))
    .filter((items) => items.length > 1);
  let emisIndex = fileHeader.map((x) => x.toLowerCase()).indexOf('emis');
  if (emisIndex < 0) {
    console.log(
      `The file ${conditionCodeSet} in ${ltcGroup} does not have a column with the header 'emiscode' or 'emisid'.`
    );
    return [];
  }
  const emisCodes = fileBody.map((items) => items[emisIndex]);

  if (emisCodes.length === 0) {
    console.log(`The file ${conditionCodeSet} in ${ltcGroup} does not have any emis codes.`);
    return [];
  }

  return emisCodes;
}

function loadCodesetSnomed(ltcGroup, conditionCodeSet) {
  const filepath = join(LTC_DIRECTORY, ltcGroup, conditionCodeSet);
  const [fileHeader, ...fileBody] = readFileSync(filepath, 'utf8')
    .split('\n')
    .map((row) => row.split('\t'))
    .filter((items) => items.length > 1);
  let snomedIndex = fileHeader.indexOf('snomed');
  if (snomedIndex < 0) snomedIndex = fileHeader.map((x) => x.toLowerCase()).indexOf('id');
  if (snomedIndex < 0) {
    console.log(
      `The file ${conditionCodeSet} in ${ltcGroup} does not have a column with the header 'snomed' or 'id'.`
    );
    return [];
  }
  const snomedCodes = fileBody.map((items) => items[snomedIndex]);
  return snomedCodes;
}

function makeArrayUnique(array) {
  return [...new Set(array)];
}
